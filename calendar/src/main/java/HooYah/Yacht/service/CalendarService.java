package HooYah.Yacht.service;

import HooYah.Yacht.domain.Calendar;
import HooYah.Yacht.domain.CalendarType;
import HooYah.Yacht.domain.CalendarUser;
import HooYah.Yacht.dto.request.CalendarCreateRequest;
import HooYah.Yacht.dto.request.CalendarUpdateRequest;
import HooYah.Yacht.dto.response.CalendarInfo;
import HooYah.Yacht.repository.CalendarRepository;
import HooYah.Yacht.excetion.CustomException;
import HooYah.Yacht.excetion.ErrorCode;
import HooYah.Yacht.webclient.WebClient;
import HooYah.Yacht.webclient.WebClient.HttpMethod;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class CalendarService {

    private final CalendarRepository calendarRepository;

    private final AskService askService;
    private final WebClient webClient;

    @Value("${web-client.gateway}")
    private String gatewayURL;
    @Value("${web-client.repair-create}")
    private String createRepairURI;

    private Logger logger = LoggerFactory.getLogger(this.getClass());

    public CalendarInfo createCalendarByUser(CalendarCreateRequest dto, Long userId) {
        // validate dto.getPartId, YachtUser, userList
        Object yachtInfo = askService.validateYachtUser(dto.getYachtId(), userId);
        Object partInfo = askService.validatePart(dto.getPartId());
        List referenceUserInfoList = askService.getUserInfoList(dto.getUserList());

        // if (type == Part) delete old calendar
        if(dto.getType() == CalendarType.PART) {
            // 동일 part의 켈린더 삭제 (생성 날짜 이전의 자동 생성된 Calendar 모두 삭제)
            List<Calendar> oldCalendarList = calendarRepository.findByPartId(dto.getPartId());

            List<Calendar> autoGeneratedCalendarList = oldCalendarList
                    .stream()
                    .filter(c->c.getStartDate().isBefore(dto.getStartDate())) // 생성 calendar 보다 이전의
                    .filter(c->!c.isByUser()) // user가 수정하지 않은
                    .filter(c->!c.isCompleted())
                    .toList(); // domain 규칙들에 속함 service에서 처리할 규칙이 아님!

            calendarRepository.deleteAll(autoGeneratedCalendarList);
        }
        Calendar newCalendar = createCalendarDomain(dto);

        createNewRepair(newCalendar, userId);

        return CalendarInfo.of(newCalendar, partInfo, yachtInfo, referenceUserInfoList);
    }

    @Transactional
    public Calendar createCalendarDomain(CalendarCreateRequest dto) {
        // calendar 생성
        Calendar newCalendar = Calendar
                .builder()
                .startDate(dto.getStartDate())
                .endDate(dto.getEndDate())
                .type(dto.getType())
                .partId(dto.getPartId())
                .content(dto.getContent())
                .review(dto.getReview())
                .yachtId(dto.getYachtId())
                .isCompleted(dto.getCompleted())
                .buildByUser();

        // calendar 참조인 처리
        newCalendar.setCalendarUsers(dto.getUserList());

        return calendarRepository.save(newCalendar);
    }

    public Calendar updateCalendar(Long id, CalendarUpdateRequest dto, Long userId) {
        Calendar calendar = calendarRepository.findById(id)
                .orElseThrow(()->new CustomException(ErrorCode.NOT_FOUND));

        askService.validateYachtUser(calendar.getYachtId(), userId);

        calendar = updateCalendarDomain(calendar, dto);

        createNewRepair(calendar, userId);
        return calendar;
    }

    @Transactional
    public Calendar updateCalendarDomain(Calendar calendar, CalendarUpdateRequest request) {
        calendar.updateDate(request.getStartDate(), request.getEndDate());
        calendar.update(request.getPartId(), request.getContent(), request.getReview());
        calendar.updateComplete(request.getCompleted()); // 실행의 순서는 domain 로직에 해당한다 -> entity 함수에 넣을 것
        calendar.setByUserTrue();

        // if 참조인이 변경되었다면,
        if(request.getUserList() != null && !request.getUserList().isEmpty()) {
            // verify userIdList
            askService.getUserInfoList(request.getUserList());
            calendar.setCalendarUsers(request.getUserList());
        }
        calendarRepository.save(calendar);
        return calendar;
    }

    public CalendarInfo getCalendar(Long id, Long userId) {
        Calendar calendar = calendarRepository.findById(id)
                .orElseThrow(()->new CustomException(ErrorCode.NOT_FOUND));

        // validate yacht user
        Object yachtInfo = askService.validateYachtUser(calendar.getYachtId(), userId);
        List userInfoList = askService.getUserInfoList(calendar.getCalenderUserIdList());

        Object partInfo = null;
        if(calendar.getPartId() != null)
            partInfo = askService.validatePart(calendar.getPartId());

        // 예전 로직 변경 : return List<Part> :: all part data by yacht -> do not return
//        List<Part> parts = null;
//        if (yacht != null) {
//            parts = partRepository.findPartListByYacht(yacht.getId()); // 요트의 모든 part list를 왜 여기서 반환하는 거지?
//        }

        return CalendarInfo.of(calendar, partInfo, yachtInfo, userInfoList);
    }

    // get calendar list by List<Yacht>
    public List<CalendarInfo> getCalendars(Long userId) {
        List<Long> yachtIdList = askService.yachtListInMemory(userId);

        // List<Long :: YachtId> 기준 모든 Calendar 조회 (날짜 순)
        List<Calendar> calendars = calendarRepository.findAllByYachtOrderByStartDate(yachtIdList);

        // select other domain dtos...
        List<List<?>> userInfoList = askService.getUserInfoListList(
                calendars
                    .stream()
                    .map((c)-> c.getCalendarUsers().stream().map(CalendarUser::getUserId).toList())
                    .toList()
        );
        List<?> partInfoList = askService.getPartInfoList(
                calendars
                        .stream()
                        .map(Calendar::getPartId) // null 포함 가능합 --> 상관없음
                        .toList()
        );
        List<?> yachtInfoList = askService.getYachtInfoList(yachtIdList);
        Map<Long, Object> yachtInfoMap = new HashMap<>();
        for(int i = 0; i < yachtIdList.size(); i++)
            yachtInfoMap.put(yachtIdList.get(i), yachtInfoList.get(i));

        List<?> sortedYachtInfoList = calendars
                .stream()
                .map(c->yachtInfoMap.get(c.getYachtId()))
                .toList();

        return CalendarInfo.of(calendars, partInfoList, sortedYachtInfoList, userInfoList);
    }

    @Transactional
    public void deleteCalendar(Long id, Long userId) {
        Calendar calendar = calendarRepository.findById(id)
                .orElseThrow(()->new CustomException(ErrorCode.NOT_FOUND));
        askService.validateYachtUser(calendar.getYachtId(), userId);
        
        calendarRepository.delete(calendar);
        // repair은 지우지 않음
    }

    public void createNewRepair(Calendar calendar, Long userId) {
        if(!calendar.isCompletedNow())
            return;

        if(calendar.getType().equals(CalendarType.PART)) {
            // repair domain에게 무한 web client 시도하기
            String uri = String.format(gatewayURL + createRepairURI + "?userId=%d", userId);
            try {
                webClient.webClient(uri, HttpMethod.POST,
                        Map.of("id", calendar.getPartId(), "date", OffsetDateTime.now(), "content", "autoGenerated")).toMap();
            } catch (CustomException e) {
                // api throw CustomException
                logger.error(e.getMessage());
            } catch (RuntimeException e) {
                // api fail
                logger.error(e.getMessage());
            }
        }
    }

//    class RequestRepairDto {
//        private Long id; // partId
//        private OffsetDateTime date;
//        private String content;
//    }

}

